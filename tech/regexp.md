# 正则表达式

## [精通正则表达式](https://book.douban.com/subject/2154713/)

### 要点

* 写正则时清楚了解目标文本是很重要的，因为你经常需要在对检索文本的了解程度和检索精度间求得平衡。
* 学习任何一门支持正则表达的语言时需要注意两点：正则流派；该语言运用正则的方式。
* 在字符组外面的元字符，在字符组中不一定是元字符，反之亦然。
	* -在字符组中的非开头被当作元字符（表范围）处理。
	* ^在字符组外开头代表字符串起始位置。在字符组内部开头代表排除。其它位置则被当作普通字符处理。$在非尾位当作普通字符。
	* .?+..等在字符组中被当作普通字符。
	* \b在Perl中通常代表单词分界符，在字符组中匹配退格符
* 排除型字符组([^...])表示匹配一个未列出的字符。
* 多选分支(|)没有字符组的排除功能([^...])
* 字符组只能也必须匹配一个字符。
* \D匹配的是某个不是数字的字符，无法匹配没有字符的情况。
* ?元字符只作用于之前紧临元素。
* ()可以界定?等元字符的作用对象，括号内的表达式从括号外看是一个整体。
* ()可以捕获文本，捕获的文本按照括号出现的先后排序。(?:)分组不捕获，能令复杂表达式变得清晰，由于不需记录捕获能够提高效率，减少内存占用。
* 空格符也是普通字符之一。
* 正则转义字符\转义的三种情况
	* \元字符 表示将元字符当作普通字符处理
	* \非元字符 表示某种元字符序列如\<在某些语言中表示单词起始边界
	* \任意字符 反斜线被忽略
* 不同语言字符串有自己的元字符并且对于转义的解释不同
	* 字符串也有自己的元字符，它与正则中元字符是有区别的，但有的相同。
	* 每种语言的字符串文字都规定了自己的元字符，有的语言包含了多种字符串文字。许多语言的字符串文字能识别转义序列，生成字符串数据时会正确的解释这些记号。
	* 很多语言提供了一种以上的字符串，一种可以解释反斜线序列，一种不解释。
	* 不同语言中字符串中对转义字符的解释可能不同。对C#和Java的字符串文字，字符串中如果出现不能明显是识别成特殊字符的反斜线序列会导致报错，而在PHP双引号字符中，这中序列会被原封不动传出来。
	* 在构建正则表达式字符串时，程序语言通常有函数能够对字符串值“上保险”。
* 我们总是要考虑在编程语言的字符串处理结束后，正则引擎接收到的是什么。
* 能够处理多行文本的工具如文本编辑器，通常不容许.匹配换行符。
* Shell也有自己承认的元字符，空格符就是其中一个。在许多Shell中，单引号也是元字符（其中的字符不需被当作元字符处理）。
* 同样写法的元字符在不同语言中可能代表不同含义。
	* Perl中@表示数组名，它的字符串和正则中也允许出现数组变量，所以若要使用@字符，需要转义。
* \s匹配所有空白字符，包括空白符、制表符、换行符、回车符。
* Perl语法
	* $v =~ m/regex/ 判断正则表达式是否匹配
	* $v =~ s/regex/replacement/ 匹配并替换字符串
	* <>相当于其他语言getline函数
	* defined函数检查某个变量是否设置了值
	* die函数用来发出错误信息，退出程序
	* /x修饰符使得正则表达式中大多数空白字符被忽略(空白符变成“忽略自身”元字符)，用户能够以free-format编排表达式，增强可读性；同时允许在表达式内部出现#开头的注释(#被解释为忽略该字符及其之后第一个换行符之前的所有字符)。
* \g的下一次处理的字符串是未匹配过的字符片段。它只应用于正则表达式自身而不应用于replacement。
* ^$通常匹配的不是逻辑行的开头和结尾，而是整个字符串的开头和结尾，也就是说中间可能有多个换行。并且它们只匹配位置，这区别于\n。
* \w能匹配[ASCII](../links/articles.md)字母和数字。但在有些系统中它也能匹配非ASCII字母。大多数流派中也能匹配下划线。
	* 1个字节8位可代表256种状态，ASCII使用了一个字节中后七位(首位0)规定了128种英文字符。
* 环视
	* 肯定环视(?=)(?<=)
	* 否定环视(?!)(?<\!)
	* 顺序环视(?=)(?!)
	* 逆序环视(?<=)(?<\!)
	* 只匹配位置
	* 有的正则引擎不支持逆序环视；支持逆序环视也可能不支持逆序引用/只能匹配固定长度文本/不容许多选分支。
		* 若逆序环视能匹配任意长度文本，引擎必须从字符串起始位置检查逆序环视表达式，如果逆序环视在长字符串尾端开始会造成很多浪费。
* \1\2..表示在正则中引用
* 正则发展历史
	* 神经学-》代数学 -〉理论数学 -》 计算机
	* 正则表达式发展初期，多种正则引擎各自演进，添加自己的特性。这中间添加的新特性字符可能普通字符冲突；新特性带来新bug；新特性添加后又被删除；无说明文档；=》无统一规范，产生了不同流派。
	* POSIX-标准化尝试，将常见的流派分为两大类。这个标准的主要特征之一是locale-一组关于语言和文化传统的设定。
	* 1986年，Henry Spenser用C语言写了一个通用的正则包。
	* Perl1-5发布。在perl中对\(?之后的字符做了限制，这样就能保留某些字符将来用于其它功能。
* 对编码的处理
	* 程序能识别这种编码吗？
	* 程序如何决定采用哪种编码护理这些数据？
	* 正则对这种编码支持程度如何？
		* 是否支持多字节？
		* \w \d \s \b之类的元字符是否能够识别编码中所有字符？
		* 程序是否会扩展对字符组的解释，如[a-z]能否匹配带音标e
		* 不区分大小写的匹配是否对所有字符都一样，例如带音标大小写
* Unicode提供了许多组合字符用来修饰一个基础字符。
	* 十六进制/unicode转义：\x{num}如\x{1D124} \unum如\u00A0
	* \num八进制转义如\015。若num超出八进制范围377，一般实现将其视为多余一个字节的值，其它则截断为一个字节。
	* \X匹配可能含有多个自己的Unicode字符。
* \g能匹配上一次匹配结束的位置，第一次迭代匹配字符串开头，就像\A，若匹配不成功\g会重新指向字符串起始位置。
* 使用固化分组(?>)：一旦括号内自表达式匹配后，匹配后的内容就固定下来。
* DFA与NFA
	* NFA是表达式主导
		* 备用状态与回溯
	* DFA是文本主导

###  概念

* 元字符-具有特殊意义的字符
* 字符组
* 基础/组合字符
* 正则模式-规定了正则表达式该如何解释和应用如/x /g /i，模式可以作用于整个表达式，也可作用于子表达式如有的流派中(?i)表示子表达式不区分大小写。
* 单行文本模式-点号不受限制可以匹配任何字符。
* 多行文本模式-影响到^和$的匹配，^匹配字符串中内嵌文本行的开头位置，$匹配字符串内部换行之前位置。支持多行的.通常不匹配\n，通常支持\A\Z分别匹配文本起始位置，不匹配换行符。有的\Z能匹配换行符，提供\z唯一匹配文本结尾。
* 文字文本模式-几乎不能识别任何正则元字符。
* 命名捕获(?<name>)，使用如\k<name>。
* 固化分组
* 标准匹配量词: ? + * {m, n}
* 匹配优先量词: 标准匹配量词都是匹配优先。
* 忽略优先量词: .\*?
* 简单/复杂锚点

### 代码片段

```
<!-- -e表示整个程序接在命令后面 -p表示对目标文本每一行进行查找替换 -i表示将替换结果写回文件 -->
perl -p -i -e 's/sysread/read/g' file

<!-- -w打开perl的额外告警功能 -->
perl -w mkreply king.in > king.out

<!-- perl -->
while($line = <>) {
	...处理$line
}

<!-- js模拟固化分组 -->
/\d\d(?=([1-9]))\1\d+/
```

### 参考

```
☞ 字符缩略表示法：\n、\t、\a、\b、\e、\f、\r、\v、…
☞ 八进制转义：\num
☞ 十六进制/Unicode转义：\xnum、\x{num}、\unum、\Unum，…

☞ 控制字符：\cchar
字符组及相关结构
☞ 普通字符组：[a-z]和[^a-z]

☞ 几乎能匹配任何字符的元字符：点号
☞ 单个字节：\C

☞ Unicode组合字符序列：\X
☞ 字符组缩略表示法：\w、\d、\s、\W、\D、\S
☞ Unicode属性、区块和分类：\p{Prop}、\P{Prop}
☞ 字符组运算符：[[a-z]&&[^aeiou]]
☞ POSIX“字符组”方括号表示法：[[：alpha：]]
☞ POSIX“collating序列”方括号表示法：[[.span-ll.]]
☞ POSIX“字符等价类”方括号表示法：[[=n=]]
☞ Emacs 语法类

锚点及其他“零长度断言”

☞ 行/字符串起点：^、\A
☞ 行/字符串终点：$、\Z、\z

☞ 本次匹配的开始位置（或者上次匹配的结束位置）：\G
☞ 单词分界符：\b、\B、\＜、\＞，….
☞ 顺序环视 （？=…）、（？！…）；逆序环视 （？＜=…）、（？＜！…）

注释和模式修饰词
☞ 模式修饰词：（？modifier），例如（？i）或（？-i）

☞ 模式作用范围：（？modifier：…），例如（？i：…）

☞ 注释：（？＃…） 和＃…

☞ 文字文本范围：\Q…\E

分组、捕获、条件判断和控制

☞ 捕获/分组括号：（…）、\1、\2，…

☞ 仅用于分组的括号：（？：…）
☞ 命名捕获：（？＜Name＞…）

☞ 固化分组：（？＞…）
☞ 多选结构：…|…|…

☞ 条件判断：（？if then|else）
☞ 匹配优先量词：＊、+、？、{num，num}
☞ 忽略优先量词：＊？、+？、？？、{num，num}？

☞ 占有优先量词：＊+、++、？+、{num，num}+
```