# 2019-02-04

* [ASCII，Unicode 和 UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)

> 一个字节一共可以用来表示256种不同的状态。ASCII 码对英语字符与二进制位之间的关系，做了统一规定。只占用了一个字节的后面7位，规定了128个字符的编码（包括32个不能打印出来的控制符号），最前面的一位统一规定为0。

> 英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。然而不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。

> Unicode，一种所有符号的编码。是一个很大的集合，现在的规模可以容纳100多万个符号，每个符号的编码都不一样。

> Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？

> UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。对于n字节的符号（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。

* [Unicode与JavaScript详解](http://www.ruanyifeng.com/blog/2014/12/unicode.html)

> Unicode源于一个很简单的想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会有乱码了。它从0开始，为每个符号指定一个编号，这叫做"码点"（code point），如U+0000 = null。

> Unicode不是一次性定义的，而是分区定义。每个区可以存放0000-FFFF种字符，称为一个平面（plane）。目前，一共有17个（25）平面。基本平面1个，存放最常见字符，码点范围U+0000-U+FFFF，剩下的字符都放在辅助平面（缩写SMP），码点范围从U+010000一直到U+10FFFF。

> 最直观的编码方法是，每个码点使用四个字节表示，字节内容一一对应码点。这种编码方法就叫做UTF-32。因为非常浪费空间，HTML 5标准就明文规定，网页不得编码成UTF-32。

> UTF-16编码介于UTF-32与UTF-8之间，同时结合了定长和变长两种编码方法的特点。它的编码规则很简单：基本平面的字符占用2个字节，辅助平面的字符占用4个字节。在基本平面内，从U+D800到U+DFFF是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。

> UTF-8是一种变长的编码方法，字符长度从1个字节到4个字节不等。越是常用的字符，字节越短，最前面的128个字符，只使用1个字节表示，与ASCII码完全相同。

> JavaScript用的是UCS-2！为什么JavaScript不选择更高级的UTF-16，而用了已经被淘汰的UCS-2呢？因为在JavaScript语言出现的时候，还没有UTF-16编码，只有UCS-2一种编码方法可用。

> 由于JavaScript只能处理UCS-2编码，造成所有字符在这门语言中都是2个字节，如果是4个字节的字符，会当作两个双字节的字符处理。ES6，大幅增强了Unicode支持，基本上解决了这个问题。

> ES6可以自动识别4字节的码点，但是，为了保持兼容，length属性还是原来的行为方式。为了得到字符串的正确长度，可以用Array.from(string).length。JavaScript允许直接用码点表示Unicode字符，写法是"反斜杠+u+码点"。ES6 只要将码点放在大括号内(\u{1D306})，就能正确识别。ES6新增了几个专门处理4字节码点的函数。ES6提供了u修饰符，对正则表达式添加4字节码点的支持。

> 有些字符除了字母以外，还有附加符号。比如，汉语拼音的Ǒ。Unicode提供了两种表示方法。一种是带附加符号的单个字符，即一个码点表示一个字符，比如Ǒ的码点是U+01D1；另一种是将附加符号单独作为一个码点，与主体字符复合显示，即两个码点表示一个字符，比如Ǒ可以写成O（U+004F） + ˇ（U+030C）。ES6提供了normalize方法，允许"Unicode正规化"，即将两种方法转为同样的序列。 '\u01D1'.normalize() === '\u004F\u030C'.normalize()


* [回车和换行符](http://www.ruanyifeng.com/blog/2006/04/post_213.html)

> 计算机出现前，有一种叫做电传打字机，每秒钟可以打10个字符。但打完一行换行的时候，要用去0.2秒，这时间内可能丢失一个字符。研制人员想了个办法-用两个字符(回车 换行)表示换行。计算机发明后，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为每行结尾加一个字符就行。于是，就出现了分歧。Unix系统里，每行结尾只有"\n"；Windows系统里面，每行结尾是"\r\n"；Mac系统里，每行结尾是"\r"。Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。

* [编程的智慧](http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy)

> 如果你总是匆匆写出代码，却从来不回头去推敲，修改和提炼，其实是不可能提高编程水平的。看一个作家的水平，不是看他发表了多少文字，而要看他的废纸篓里扔掉了多少。

> 你可以把代码看成是一个电路，电流经过导线，分流或者汇合。如果你是这样思考的，你的代码里就会比较少出现只有一个分支的if语句。使用有两个分支的if语句，包含了使代码可靠的一种通用思想：穷举所有的情况，不漏掉任何一个。

> 真正的模块化，并不是文本意义上的，而是逻辑意义上的。一个模块应该像一个电路芯片，它有定义良好的输入和输出。实际上一种很好的模块化方法早已经存在，它的名字叫做“函数”。每一个函数都有明确的输入（参数）和输出（返回值）。

> 想要达到很好的模块化，你需要做到以下几点：避免写太长的函数; 制造小的工具函数； 每个函数只做一件简单的事情。如果一个函数可能做两种事情，它们之间共同点少于它们的不同点，那你最好就写两个不同的函数，否则这个它的逻辑就不会很清晰，容易出错。； 避免使用全局变量和类成员（class member）来传递信息，尽量使用局部变量和参数。

> 实际上，真正优雅可读的代码，是几乎不需要注释的。如果你充分利用了程序语言的表达能力，你完全可以用程序本身来表达它到底在干什么，而不需要自然语言的辅助。

> 一些要点，也许可以帮助你大大减少写注释的必要：使用有意义的函数和变量名字；局部变量应该尽量接近使用它的地方，局部变量就像是电路里的导线；局部变量名字应该简短；不要重用局部变量。重新定义新的局部变量能让你清楚得看到变量的作用范围；把复杂的逻辑提取出去，做成“帮助函数”；把复杂的表达式提取出去，做成中间变量；在合理的地方换行。

> 避免使用自增减表达式（i++，++i，i–，–i）。这种自增减操作表达式其实是历史遗留的设计失误。它们把读和写这两种完全不同的操作，混淆缠绕在一起。含有它们的表达式，结果可能取决于求值顺序，所以它可能在某种编译器下能正确运行，换一个编译器就出现离奇的错误。

> 永远不要省略花括号。合理使用括号，不要盲目依赖操作符优先级。避免使用continue和break。

> 如果有更加直接，更加清晰的写法，就选择它，即使它看起来更长，更笨，也一样选择它。

> 程序的绝大部分功能，是进行信息处理。从一堆纷繁复杂，模棱两可的信息中，排除掉绝大部分“干扰信息”，找到自己需要的那一个。正确地对所有的“可能性”进行推理，就是写出无懈可击代码的核心思想。这种思想可以应用在错误处理上。

> 过度工程即将出现的一个重要信号，就是当你过度的思考“将来”，考虑一些还没有发生的事情，还没有出现的需求。比如，“如果我们将来有了上百万行代码，有了几千号人，这样的工具就支持不了了”，“将来我可能需要这个功能，所以我现在就把代码写来放在那里”，“将来很多人要扩充这片代码，所以现在我们就让它变得可重用”……。另外一种过度工程的来源，是过度的关心“代码重用”。

> 根据这些，我总结出来的防止过度工程的原则如下：
* 先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。
* 先写出可用的代码，反复推敲，再考虑是否需要重用的问题。
* 先写出可用，简单，明显没有bug的代码，再考虑测试的问题。

* [怎样成为一个天才](http://www.yinwang.org/blog-cn/2014/08/11/genius)

> 天才的价值并不在于快，而在于他们能想出其他人都想不出来的东西。天才喜欢反复审视前进的方向，所以他们经常能找到偷懒的方法。天才喜欢偷懒，并且利用巧妙的设计让大家都可以偷懒。

> Learning by doing。Nash 看书只看封面和开头，把这书要讲的问题了解清楚之后，就自己动手解决。费曼也说：“我不知道这个东西的名字，但我却知道这个东西是什么。”。天才往往依靠自己的直觉和想象力，而不是经验。

> 人们常说，天才出于勤奋，所以首要的一点是你必须为此投入巨额的努力，甚至做出巨大的牺牲。

> 但仅有艰苦卓绝的勤奋，也不一定能成为天才。你必须把勤奋用在巧妙的地方。书籍能使你记住现成的“事实”，却不能让你拥有产生出这些知识的能力。它们只是把你“训练”（train）成了循规蹈矩的流水线工人，而不能让你受到真正的“教育”（education）。所以我的建议是：如果你想成为天才，就避免去读厚书。去寻找简短的书来入门，然后就可以自己思考了。这就是我从 Nash 的故事得到的启发。

> 笛卡尔（René Descartes）写过一篇文章，讲述如何成为一个天才。他说，在人生中的某个时候，他决定开始仔细检查自己头脑里的思想。他翻出自己所有的想法，寻找它们的最初的“来源”，然后审视它们。这种来源有可能是父母，有可能是传统，有可能是学术权威。当他发现某个来源有问题的时候，他就抛弃从这个来源获得所有想法。

> 要成为天才，必须要能够打破别人设下的思维圈套，去除自己头脑里的各种权威。你必须使用直觉（或者图形），而不是符号（或者文字）进行思考，因为人脑根本不是用符号进行思考的。

> 真正的天才，比如 Nash 和 Feynman，都是用直觉思考的。别人的公式在进入他们头脑里时，首先被翻译成某种“思维模型”，然后他们的头脑对这种模型进行思考。他们通过直觉对这些模型进行变换操作，得出结果。然后他们用符号把这结果表示出来，为的是给其他人看。

> 为了得到直觉，你必须去接近自然界，必须出去寻找灵感，蹲在家里看书，思考，会让你的思维局限于文字和符号所能表示的东西，没法达到突破。如果你能看到我的头脑如何思考，你就会发现，当我的眼睛看到代码或者公式的时候，我的头脑看到的并不是代码和公式，而是自动把它们翻译成了一些电路，流体导管一类的东西，它们存在于一个具有多重现实和历史的，像 Matrix 一样的世界里。这些直觉都不是从书里来的，也不是老师教的，而是通过观察身边的事物得到的。

> 另外，你还需要休息。很多人一天学到晚，一天想到晚，以为这样就可以有所成就。可是人脑需要足够的休息和间歇的时间，才能从你想过的，看过的东西里面提取出精华的东西。Feynman 有个方法我觉得很管用。他说，如果你想成为天才，就在你的头脑里随时准备好12个需要解决的问题。每当你的生活中发生一件事，就把这些问题拿出来检查一下，看其中是否有问题会得到进展。

